/*
	Simple Encryption ALgorithm (SEAL)
    Author: Joseph St. Pierre

    The Simple Encryption ALgorithm (SEAL) is a symmetric key block cipher that
    securely permutes a 128 bit block against a 128 bit key at a rate of 45+ MB/s making it suitable
    for encrypting large amounts of data fairly quickly without any hardware acceleration.

    NOTE: As of now the algorithm is undergoing academic review and as such should NOT be implemented for professional use until
        the review process concludes that SEAL is in fact usable for such purposes. In its current form, the algorithm should only
        be used for educational purposes.

        If any potential vulnerabilites to the cipher design are discovered during its review process, they will be corrected and
        the implementation described here will be updated accordingly.

    CONTACT:
        Author: Joseph St. Pierre
        Email: jkstpierre@wpi.edu

    Please email me if you discover any potential exploits!

    The author claims no responsibility for any and all damages that arise from the usage of this software. If you use
    SEAL in its current state to protect sensitive data in contradiction of the author's express warning: YOU DO SO AT YOUR
    OWN RISK!

    Once the review process is concluded, you are free to use SEAL
    for any commercial applications provided that you give credit to the author, and that the algorithm is only used as
    an auxiliary within a greater project and is not the main selling point of the application.

    Released: August 2017
*/

/*
    Copyright Â© 2017 Joseph St. Pierre

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "seal.h"

/*
    SEAL Substitution Box
    NOTE: The S-box provided here was generated via a brute-force search for an S-box
          with good avalanche effect and bit distribution. Any S-box will work for SEAL
          provided it has the aforementioned properties.
*/
uint8_t sbox[256] = {
    0xbc, 0x7d, 0x7b, 0x93, 0x01, 0x15, 0x30, 0x21, 0xa5, 0xd6, 0xf8, 0x9b, 0x48, 0xdb, 0xce, 0x29,
    0x61, 0xb3, 0x34, 0x03, 0xb1, 0xd7, 0x53, 0x98, 0x52, 0xf3, 0xbb, 0xab, 0xb2, 0x2d, 0x2a, 0xeb,
    0x08, 0x02, 0x0c, 0xcb, 0xb0, 0x9e, 0x8f, 0x96, 0x40, 0x92, 0xe9, 0x6e, 0x58, 0x6d, 0x44, 0x06,
    0x88, 0x1c, 0x1f, 0x65, 0x91, 0x85, 0x66, 0x45, 0x9d, 0x4a, 0xb9, 0x8d, 0x20, 0xca, 0xa0, 0x19,
    0x5d, 0x5b, 0x12, 0x25, 0xcc, 0x9c, 0x43, 0xa2, 0x50, 0xda, 0xb4, 0xf9, 0x4f, 0x69, 0x17, 0x4b,
    0x04, 0x6c, 0x11, 0xdd, 0x73, 0x16, 0xdf, 0x41, 0x3a, 0x5f, 0x74, 0x47, 0x09, 0x18, 0xfe, 0x99,
    0x84, 0x62, 0x00, 0x0d, 0x64, 0x7c, 0xd5, 0x72, 0xe1, 0xe5, 0x24, 0xee, 0x4d, 0xf2, 0x3d, 0x2c,
    0x26, 0x3b, 0x42, 0x3f, 0xc2, 0x7a, 0xd3, 0x1d, 0x57, 0x0b, 0xfa, 0x75, 0xd0, 0xc4, 0xec, 0xfb,
    0x0e, 0xe3, 0x90, 0x80, 0xff, 0x0a, 0x4e, 0x2f, 0xd9, 0x2e, 0xc8, 0xe6, 0x1b, 0x94, 0x55, 0x9a,
    0xf5, 0x60, 0x79, 0xd2, 0x71, 0xcf, 0xdc, 0xad, 0xf7, 0x7f, 0xc0, 0x05, 0x6b, 0xaf, 0x38, 0x7e,
    0xd8, 0x35, 0x70, 0xc9, 0xaa, 0x83, 0xa6, 0xd1, 0x39, 0xe0, 0x6a, 0x67, 0xa4, 0x5a, 0x13, 0x8b,
    0xf0, 0xfc, 0xe7, 0xc6, 0xa3, 0x97, 0xc3, 0x5e, 0xc7, 0x63, 0x46, 0xba, 0x37, 0xea, 0x77, 0xc1,
    0xcd, 0x4c, 0x33, 0xbf, 0x28, 0x76, 0xb5, 0xb7, 0xf4, 0xed, 0x5c, 0xfd, 0x68, 0xae, 0xe4, 0x78,
    0xe2, 0x1e, 0x2b, 0xac, 0x59, 0x36, 0xbe, 0x6f, 0x1a, 0xb6, 0x9f, 0x22, 0x87, 0x8c, 0x10, 0x31,
    0x82, 0xa9, 0x07, 0xf6, 0x86, 0x23, 0xe8, 0x95, 0x54, 0xa8, 0x81, 0x8a, 0xa1, 0x49, 0xf1, 0xb8,
    0xd4, 0x3e, 0x0f, 0xde, 0x3c, 0x8e, 0x56, 0xc5, 0x27, 0x89, 0x14, 0xbd, 0x51, 0xa7, 0x32, 0xef
};

/*
    SEAL Inverse Substitution Box
*/
uint8_t inv_sbox[256] = {
    0x62, 0x04, 0x21, 0x13, 0x50, 0x9b, 0x2f, 0xe2, 0x20, 0x5c, 0x85, 0x79, 0x22, 0x63, 0x80, 0xf2,
    0xde, 0x52, 0x42, 0xae, 0xfa, 0x05, 0x55, 0x4e, 0x5d, 0x3f, 0xd8, 0x8c, 0x31, 0x77, 0xd1, 0x32,
    0x3c, 0x07, 0xdb, 0xe5, 0x6a, 0x43, 0x70, 0xf8, 0xc4, 0x0f, 0x1e, 0xd2, 0x6f, 0x1d, 0x89, 0x87,
    0x06, 0xdf, 0xfe, 0xc2, 0x12, 0xa1, 0xd5, 0xbc, 0x9e, 0xa8, 0x58, 0x71, 0xf4, 0x6e, 0xf1, 0x73,
    0x28, 0x57, 0x72, 0x46, 0x2e, 0x37, 0xba, 0x5b, 0x0c, 0xed, 0x39, 0x4f, 0xc1, 0x6c, 0x86, 0x4c,
    0x48, 0xfc, 0x18, 0x16, 0xe8, 0x8e, 0xf6, 0x78, 0x2c, 0xd4, 0xad, 0x41, 0xca, 0x40, 0xb7, 0x59,
    0x91, 0x10, 0x61, 0xb9, 0x64, 0x33, 0x36, 0xab, 0xcc, 0x4d, 0xaa, 0x9c, 0x51, 0x2d, 0x2b, 0xd7,
    0xa2, 0x94, 0x67, 0x54, 0x5a, 0x7b, 0xc5, 0xbe, 0xcf, 0x92, 0x75, 0x02, 0x65, 0x01, 0x9f, 0x99,
    0x83, 0xea, 0xe0, 0xa5, 0x60, 0x35, 0xe4, 0xdc, 0x30, 0xf9, 0xeb, 0xaf, 0xdd, 0x3b, 0xf5, 0x26,
    0x82, 0x34, 0x29, 0x03, 0x8d, 0xe7, 0x27, 0xb5, 0x17, 0x5f, 0x8f, 0x0b, 0x45, 0x38, 0x25, 0xda,
    0x3e, 0xec, 0x47, 0xb4, 0xac, 0x08, 0xa6, 0xfd, 0xe9, 0xe1, 0xa4, 0x1b, 0xd3, 0x97, 0xcd, 0x9d,
    0x24, 0x14, 0x1c, 0x11, 0x4a, 0xc6, 0xd9, 0xc7, 0xef, 0x3a, 0xbb, 0x1a, 0x00, 0xfb, 0xd6, 0xc3,
    0x9a, 0xbf, 0x74, 0xb6, 0x7d, 0xf7, 0xb3, 0xb8, 0x8a, 0xa3, 0x3d, 0x23, 0x44, 0xc0, 0x0e, 0x95,
    0x7c, 0xa7, 0x93, 0x76, 0xf0, 0x66, 0x09, 0x15, 0xa0, 0x88, 0x49, 0x0d, 0x96, 0x53, 0xf3, 0x56,
    0xa9, 0x68, 0xd0, 0x81, 0xce, 0x69, 0x8b, 0xb2, 0xe6, 0x2a, 0xbd, 0x1f, 0x7e, 0xc9, 0x6b, 0xff,
    0xb0, 0xee, 0x6d, 0x19, 0xc8, 0x90, 0xe3, 0x98, 0x0a, 0x4b, 0x7a, 0x7f, 0xb1, 0xcb, 0x5e, 0x84
};

/*
	Substitute the bytes of a block with the SEAL S-Box
*/
void S(uint32_t *block){
    for(int i = 0; i < 4; i++){
        uint8_t byte = (uint8_t)(*block >> 8*i);
        *block = *block & ~(0xFF << 8*i);   //Clear the bits
        *block |= ((uint32_t)sbox[byte] << 8*i); //Substitute the byte
    }
}

/*
	Substitute the bytes of a block through the inverse S-Box
*/
void INV_S(uint32_t *block){
    for(int i = 0; i < 4; i++){
        uint8_t byte = (uint8_t)(*block >> 8*i);
        *block = *block & ~(0xFF << 8*i);   //Clear the bits
        *block |= ((uint32_t)inv_sbox[byte] << 8*i); //Substitute the byte
    }
}

/*
	Encrypt 128 bit block using SEAL:
		Permutes the block against the provided key using the Simple Encryption ALgorithm.

		After encryption, block will contain the cipher text.

        NOTE:
            SEAL assumes that both the block and the key are 128 bits long. If either the key or the block deviate
            from this assumed bit length, undefined behavior will occur!
*/
void seal_encrypt(uint32_t block[4], const uint32_t key[4]){
	uint32_t carry = 0;	//The carry block for permutation

	//For each round of encryption
	uint32_t i;
	for(i = 0; i < ROUND_COUNT; i++){
		S(&block[0]);	//Run first block through the S-box
		block[0] ^= key[i&0b11] ^ i;  //Compute the XOR on the block
		carry = block[0];	//Set the carry

        carry = (carry >> 11) | (carry << (32 - 11));   //Rotate the carry

        //Permute subsequent blocks using modular addition in the finite field 2^32
		block[1] += carry;
		carry = block[1];

        carry = (carry >> 11) | (carry << (32 - 11));

		block[2] += carry;
		carry = block[2];

        carry = (carry >> 11) | (carry << (32 - 11));

		block[3] += carry;
		carry = block[3];

		//Rotate the blocks
		block[3] = block[2];
		block[2] = block[1];
		block[1] = block[0];
		block[0] = carry;
	}

	//Prepare the blocks
    S(&block[0]);
    S(&block[1]);
    S(&block[2]);
    S(&block[3]);

    //Apply the final XOR
    for(i = 0; i < 4; i++){
    	block[i] ^= key[i];
    }
}

/*
	Decrypt 128 bit block using SEAL:
        Permutes the cipher-text block against the provided key using the Simple Encryption ALgorithm.

        After decryption, block will contain the plaintext.

        NOTE:
            SEAL assumes that both the block and the key are 128 bits long. If either the key or the block deviate
            from this assumed bit length, undefined behavior will occur!
*/
void seal_decrypt(uint32_t block[4], const uint32_t key[4]){
	uint32_t carry = 0;	//Carry block for permutations
	int i;	//Iterator for the for loops

	//Unlock the block against the key
	for(i = 0; i < 4; i++){
		block[i] ^= key[i];
    }

	//Invert the blocks
	INV_S(&block[0]);
	INV_S(&block[1]);
	INV_S(&block[2]);
	INV_S(&block[3]);

	//For each round
	for(i = ROUND_COUNT - 1; i >= 0; i--){
		//Rotate the blocks
		carry = block[0];	//Set the carry
		block[0] = block[1];
		block[1] = block[2];
		block[2] = block[3];
		block[3] = carry;

		carry = block[2];	//Set carry to the third block
        carry = (carry >> 11) | (carry << (32 - 11));
		block[3] -= carry;	//Subtract carry from fourth block

		carry = block[1];	//Set carry to the second block
        carry = (carry >> 11) | (carry << (32 - 11));
		block[2] -= carry;	//Subtract carry from third block

		carry = block[0];	//Set carry to the first block
        carry = (carry >> 11) | (carry << (32 - 11));
		block[1] -= carry;	//Subtract carry from second block

		block[0] ^= key[i&0b11];	//XOR first block by round key
		INV_S(&block[0]);	//Invert first block through S-box
	}
}
